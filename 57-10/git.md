# Что такое Git и зачем он нужен?

## Введение
Git $-$ это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок $-$ полезно для дизайнеров.

С помощью Git'a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Репозиторием называют хранилище вашего кода и историю его изменений. Git работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.

Так же ваши репозитории можно хранить и в интернете. Обычно для этого используют три сервиса:
* GitHub
* Bitbucket
* GitLab

Каждая точка сохранения вашего проекта носит название коммит (commit). У каждого commit'a есть hash (уникальный id) и комментарий. Из таких commit'ов собирается ветка. Ветка $-$ это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.


## Установка Git'а

* Windows
  * [Официальная сборка](https://git-scm.com/download/win) (при установке оставляйте всё дефолтным $-$ не прогадаете)
* Mac OS
  * нужно попробовать выполнить команду `git --version`. если Git'а нет, то предложит установить
  * но [вот](https://git-scm.com/download/mac) официальная сборка на всякий случай
* Linux
  * `sudo apt install git`

## Оффтоп: базовые консольные команды

* Если у вас Windows, то нужно открыть Git Bash, который мы установили на прошлом шаге (PowerShell НЕ подходит)
* Если у вас Mac или Linux, то нужно открыть терминал

---

1. `pwd` (print working directory) $-$ печатает директорию, в которой вы сейчас находитесь
2. `whoami` $-$ печатает имя текущего пользователя
3. `ls` (**L**i**S**t) $-$ печатает список не-скрытых файлов и папок в текущей папке (`ls -lt` $-$ сортировка по времени последней модификации с выдачей полной информации о файлах и папках)
4. `cd TARGET_DIRECTORY` (change directory) $-$ меняет текущую директорию на `TARGET_DIRECTORY`, которая может записываться относительным путём (`.` = текущая директория) или абсолютным путём.
5. `mkdir DIR_NAME` (make directory) $-$ создаёт директорию с названием `DIR_NAME`
6. `touch FILE_NAME` $-$ создаёт файл с названием `FILE_NAME`
7. `cp SOURCE_PATH TARGET_PATH` $-$ копирует файл
8. `mv SOURCE_PATH TARGET_PATH` $-$ перемещает файл
9. `rm PATH` $-$ удаляет файл (чтобы удалить директорию надо добавить флаг `-r`: `rm -r PATH`)
10. `cat PATH` $-$ показывает содержимое текстового файла
11. `echo TEXT >> PATH` $-$ записывает TEXT в ваш файл

## GitHub

[GitHub](https://github.com/) $-$ это самый популярный ресурс для хранения репозиториев. На нём мы и будем тренироваться.

### Создание репозитория

Чтобы ваш репозиторий оказался в интернете, нужно там его создать.
1. Зайдите на гитхаб, залогиньтесь там
2. В верхнем правом углу нажмите на плюсик > New repository
3. Введите название
4. Давайте пока сделаем публичный репозиторий, а не приватный
5. Зелёная кнопка Create repository

Теперь у вас есть репозиторий и у него есть адрес в адресной строке. Давайте научимся делать так, чтобы этот репозиторий оказался у вас на компьютере.

### Клонирование репозитория

1. Создайте у себя на компьютере папку, в которой будете работать. Сделайте это в каком-нибудь месте, где точно не будет проблем с записью новых файлов.
2. Откройте в этой папке терминал / GitBash или просто запустите приложение и перейдите в нужную папку с помощью `cd`.
3. Склонируйте репозиторий. Для этого введите команду `git clone АДРЕС_ВАШЕГО_РЕПОЗИТОРИЯ`. `git clone` по дефолту создаёт папку с названием вашего репозитория в текущей директории и кладёт в неё всё содержимое. Это поведение можно изменить: `git clone АДРЕС_ВАШЕГО_РЕПОЗИТОРИЯ ПУТЬ_К_ПУСТОЙ_ПАПКЕ`.
4. Гит предупредит вас о том, что вы склонировали пустой репозиторий.
5. Выберите любой не-пустой репозиторий на гитхабе и попробуйте его склонировать, проверьте, что всё получилось.

### Что внутри?

1. Перейдите в папку с вашим репозиторием из терминала (команда `cd НАЗВАНИЕ_ПАПКИ`)
2. Проверьте содержимое с помощью команды `ls` (должно быть пусто)
3. Проверьте содержимое с помощью команды `ls -a`: что вы увидели? Как вы думаете, что это такое?

### Добавление файлов в репозиторий

1. Создайте текстовый файл с произвольным названием
2. Напишите в него что-нибудь
3. Напишите `git status`, появится что-то такое:
```console
$ git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        1.txt

nothing added to commit but untracked files present (use "git add" to track)
```
4. Чтобы добавить файл которые вы создали нужно написать `git add НАЗВАНИЕ_ФАЙЛА`
5. Снова напишите `git status`
```console
$ git status
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   1.txt
        
```
6. Попробуйте создать файл, который будет называться `мой файл.txt`. И добавьте его с помощью `git add`. Как это сделать?
7. Попробуйте создать папку и создать в ней несколько файлов. Как их добавить с помощью `git add`?
8. Найдите в интернете способ добавить сразу все файлы с помощью `git add`

Что делает `git add`? Он делает так, чтобы git индексировал файлы (знал про них) и мог с ними как-то работать. Если же вы хотите удалить что-то, то это `git rm`

### Коммит

Уже несколько раз мы видели слово commit, но ещё ни разу его не использовали сами. Коммит $-$ это такая контрольная точка, если после него что-то пойдёт не так, мы откатиться то него. Коммиты $-$ это главный инструмент контроля версий.

Чтобы сделать коммит, нужно написать `git commit -m "краткое описание коммита"`. О том, как называть коммиты по стандартам, можно почитать [тут](https://www.conventionalcommits.org/ru/v1.0.0/). Не забывайте добавлять флаг `-m` (message), иначе вас выкинет в текстовый редактор в консоли.

Если же вы забыли про флаг `-m`, то вас должно перебросить в vim и будет что-то такое:

```vim
 
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch main
# Your branch is ahead of 'origin/main' by 2 commits.
#   (use "git push" to publish your local commits)
#
# Changes to be committed:
#       new file:   my_file.txt
#
~
~
```

Для того, чтобы выйти отсюда, надо:
1. нажать `I` на клавиатуре, чтобы перейти в режим ввода (внизу появится `-- INSERT --`);
2. ввести краткое описание вашего комита в первой строчке
3. нажать `Esc` на клавиатуре, чтобы выйти из режима ввода
4. ввести `:wq` (введется внизу, где раньше появился `-- INSERT --`), что значит **w**rite and **q**uit.
5. нажать  `Enter` на клавиатуре
6. вы прекрасны (и вернулись в Git bash / терминал)

Сделав коммит вы создали контрольную точку, но только у себя на компьютере. Информация об этом коммите появилась в скрытой папке `.git`, но больше об этом никто не знает. Зачем же мы тогда сделали репозиторий в интернете?

### Push

Чтобы информация о коммите дошла до его оригинального источника в интернете, нужно запушить коммит(ы). Сделать это легко: `git push`.
Если вы делаете это первый раз, то Git попросит вас авторизироваться:
1. Нужно будет выполнить две команды. Эти команды показывают, какое имя и какой адрес электронной почты будут отображаться на ваших коммитах.
```console
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```
2. Во время пуша он ещё может попросить у вас логин и пароль. ПАРОЛЬ ЭТО НЕ ПАРОЛЬ, это особый токен. Инструкция о том, где его взять, находится [тут](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).
3. После того, как вы всё введёте, случится пуш и ваши коммиты окажутся в интернете.
4. Откройте страницу с вашим репозиторием на гитхабе, проверьте коммиты.

### Доступ к репо из разных источников

Вы можете редактировать свой репозиторий через сайт гитхаба.

1. Создайте новый файл через сайт.
2. Убедитесь, что он не появился у вас в папке.
3. Напишите в терминале команду `git pull`. Она подтянет все изменения из оригинального репозитория.


## Выше было введение, теперь рассмотрим коллективную работу


Ветка $-$ это набор коммитов, которые идут друг за другом. У ветки есть название, основную ветку чаще всего называют master или main. Если говорить простыми словами, то ветка master $-$ это наш проект.

Другие ветки $-$ это отдельное место для реализации нового функционала или исправление багов нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master.

--------------------------------------------------------------------------------
Не рекомендуется создавать commit напрямую в master. Лучше для этого заводить новую ветку и все изменения писать там.
--------------------------------------------------------------------------------


Для того, чтобы создать новую ветку вводим:

```console
git branch НАЗВАНИЕ_ВЕТКИ
```

или вот так

```console
git checkout -b НАЗВАНИЕ_ВЕТКИ
```

Эти команды делают тоже самое, только второй вариант позволяет сразу переключиться в новую ветку (в первом случае надо добавить `git switch НАЗВАНИЕ_ВЕТКИ`). Вносить изменения в новую ветку можно сразу после ее создания.


При создании новой ветки, старайтесь называть ее кратким и ёмким именем. Чтобы сразу было понятно, что именно изменялось по проекту. Если вы используете, какую-нибудь систему для ведения задач, то можете в начале названия ветки указывать ID задачи, чтобы можно было легко найти, на основе какой задачи была создана ветка. Например вот так:

`dev-3334_fix_catalog_endpoints`

Для того чтобы посмотреть текущее состояние ветки, например, какие файлы добавлены или не добавлены для создания commit, можно выполнить команду:
```console
git status
```

После того, как завершили работу над своей задачей, ветку можно слить в `main`. Для этого нужно сделать `git merge НАЗВАНИЕ_ВЕТКИ`.
### Вспомогательные команды

Просмотреть изменения относительно двух веток можно командой:
```console
git diff
```

Удалить ненужную ветку:
```console
git branch -d НАЗВАНИЕ_ВЕТКИ
```

Просмотр историю ветки:
```console
git log
```

Команды, которые надо знать
* `git help` $-$ подсказки
* `git clone` $-$ клонирование репо
* `git status` $-$ статус относительно коммита
* `git branch` $-$ действия над ветками
* `git checkout / switch` $-$ переключение веток
* `git merge` $-$ мердж веток
* `git push` $-$ подтянуть локальные изменения на GitHub
* `git pull` $-$ подтянуть изменения на GitHub'e в локальную копию
* `git init` $-$ создание репо

### Полезные ресурсы:
* все, что вы найдете на [git-scm](https://git-scm.com/), например [туториал по гиту](https://git-scm.com/docs/gittutorial) или [книжка Pro Git](https://git-scm.com/book/en/v2) (есть на [русском](https://git-scm.com/book/ru/v2))
* [Git How To](https://githowto.com/) $-$ интерактивный туториал (тоже есть на [русском](https://githowto.com/ru), но в чуть более сжатом формате)

# Гит для параллельной работы

Git нужен не только для того, чтобы хранить разные версии вашего проекта, но и для того, чтобы вместе с кем-то работать над проектом.

## Что мы научимся делать?
* форкать чужие репозитории
* сабмитить пул реквесты к чужим репо
* решать мёрдж конфликты

## Активности
### Активность 1

Найдите себе кого-нибудь в пару. Эта пара будет происходить с партнёром, чтобы посмотреть, что происходит, когда несколько людей работают над одним git репозиторием. 

Важно: вам придётся меняться ролями для каждого задания, чтобы все попробовали себя в обеих ролях, которые дальше будут отмечаться как **Петя** и **Вася**. Разбираться первый раз вам придётся вдвоём, поэтому второму будет всегда проще.

### Активность 2: засабмитить и отревьюить пул реквест
**Эта активность будет целиком на гитхабе, без командной строки**

1. **Вася**: создаёт репозиторий, над которым Петя и Вася дальше будут работать.
2. **Петя**: переходит по ссылке на гитхаб страничку этого репозитория. В правом верхнем углу нажимает кнопку `Fork`. Это создаст дубль копию репозитория Васи, которой сейчас владеет Петя.
3. **Петя**: смотрит на главную гитхаб страницу со своими репозиториями и находит там форкнутый репозиторий. Снизу там подписано что-то типа "forked from оттуда-то". Гитхаб трэкает откуда вы стащили репозиторий.
4. **Вася**: обновляет страницу со своим репозиторием, но никакой новой инфомрации там не появляется. Форк Пети никак не влияет на репозиторий Васи.
5. **Петя**: делает какие-то изменения в файлы в своём форкнутом репозитории, а потом комиттит изменения.
6. **Вася**: делает изменения в **другом** файле в этом репозитории и комиттит изменения
7. **Петя**: возвращается на главную страницу репозитория и создаёт пулл реквест с закомиченными изменениями. И сабмитит пулл реквест.
8. **Вася**: немножко ждёт и обновляет страницу репозитория: должно прийти уведомление о пулл реквесте. Вася открывает его, пишет комментарий и затем мёрджит.
9. **Вместе**: на разных компьютерах вернитесь на главную страницу ваших проектов (оригинального и форкнутого). Перейдите на вкладку Insights, потом Network. Понаводите мышку на точки и посмотрите, что они показывают. Одно ли это и то же? Обсудите с партнёром, что вы видите и почему оно выглядит так.

### Активность 3: доведите до мёрдж конфликта и решите его
**Эта активность будет как на гитхабе, так и в командной строке**. Каждая инструкция будет отмечена либо как [gh], либо как [cmd].

1. **Вася**: [gh] выбирает и форкает репозиторий Пети. Это репозиторий, в который оба будут контрибьютить.
2. **Вася**: [cmd] клонирует себе на комп форкнутый репозиторий.
3. **Петя**: [gh] выбирает относительно длинную строку в существующем файле и делает там маааленькое изменение, которое коммитит.
4. **Вася**: [cmd / text editor] делает *другое* изменение в строке, которую поменял Петя, и сохраняет файл.
5. **Вася**: [cmd] stage'ит коммит (`git add`), потом коммитит это, а потом пушит в свой репозиторий.
6. **Вася**: [gh] обновляет главную страницу форкнутого репозитория. Должно появиться следующее сообщение: "This branch is 1 commit ahead, 1 commit behind ПЕТЯ/master". Что это значит?
   * репозиторий на один коммит впереди, потому что Вася сделал 1 коммит после того, как форкнул
   * репозиторий на один коммит позади, потому что Петя сделал 1 коммит, после того, как Вася форкнул
   * И это уже говорит о том, что пулл реквест сейчас $-$ это плохая идея. Прежде, чем отсылать пулл реквест в оригинальный репозиторий, нужно убедиться, что мы посмотрели на всё новое, что произошло в этом репозитории после форка.
7. **Вася**: [gh] нажимает кнопку New pull request и видит сообщение Can't automatically merge.
   * Это значит, что гит не знает, как правильно смёрджить Васины изменения с Петиными, потому что они были на одинаковых строчках. Поэтому придётся кому-то мёрджить ручками.
   * Так как это репозиторий **Пети**, то это *Васина* ответственность замёрджить все изменения Пети к себе.
8. **Вася**: [gh] нажимает кнопку назад, чтобы перестать делать пулл реквест.
9. **Вася**: [cmd] вводит следующую команду в командную строку, заменяя то, что в угловых скобках на нужный адрес
```cmd
git pull https://github.com/<PETYA'S USER NAME>/<REPO NAME>.git
```
И должно выйти вот такое сообщение:
```cmd
CONFLICT (content): Merge conflict in <CONFLICTED FILE>
Automatic merge failed; fix conflicts and then commit the result.
```
10. **Вася**: [cmd / text editor] открывает конфликтующий файл. Должно быть две копии конфликтующей строки, окружённые `<<<<` и `>>>>`. Например, это должно выглядеть вот так:

```
<<<<<<< HEAD
**City:** Philadelphia
=======
**Current City:** Фили
>>>>>>> 8907ab85c55e86a151ac1c584fb7251783f81289
```

11. **Вася**: [cmd / text editor] всё правит и избавляется от лишних символов (`<<<`/`===`/`>>>`)
12. **Вася**: [cmd] всё добавляет и коммитит.
13. **Вася**: [gh] обновляет страницу проекта, там будет написано что-то типа This branch is 2 commits ahead of ...
14. **Вася**: [gh] нажимает кнопку New pull request и дальше создаёт пулл реквест с описанием того, что в нём случилось.
15. **Петя**: [gh] обновляет страницу и видит пулл реквест, открывает его и смотрит на изменения в файлах, комментит их и мёрджит.
16. **Вместе**: опять посмотрите на вкладку Graphs


## Если осталось время:
Попробовать сделать всё то же самое, но с ветками, а не с форками.
